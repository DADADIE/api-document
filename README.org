
** 文档

    收集项目中的接口文档, 跟随项目

** 使用

添加引用(需要 jackson 和 lombok 以及 spring mvc 相关的包)
#+BEGIN_SRC xml
<dependency>
    <groupId>com.github.liuanxin</groupId>
    <artifactId>api-info</artifactId>
    <version>1.0.4</version>
</dependency>
#+END_SRC

添如下配置
#+BEGIN_SRC java
@EnableApiInfo
public class ApiInfoConfig {
    @Bean
    public DocumentCopyright urlCopyright() {
        // 线上环境文档对应的接口将不会输出
        return new DocumentCopyright()
                    .setContact("联系")
                    .setTeam("团队")
                    .setVersion("文档版本号")
                    .setOnline(true 表示是线上环境)
                    // 当某些接口不好标 @ApiIgnore 时(格式: url|method, 也可以只传入 url 而忽略 method 匹配)
                    .setIgnoreUrlList(忽略的 url 列表);
    }
}
#+END_SRC

而后需要在对应的 controller 层标注相应的注解. 相关注解如下
#+BEGIN_EXAMPLE
@ApiGroup   标注在类或方法上. 表示当前接口隶属哪个模块. 如果类上和方法上都标了则以方法上的为准
  value   请务必设置此值, 示例(name-说明, 如: user-用户模块), 可以有多个, 也就是说一个接口可以在多个模块中出现

@ApiIgnore  标注在类或方法上. 当想要在某个类或接口上忽略收集时, 使用此注释
  value   值如果是 false 则表示不忽略. 类上和方法上都标了则以方法上的为准

@ApiMethod  标注在方法上
  title   接口标题, 请务必设置此值
  desc    接口详细说明
  develop 开发者及联系方式, 请务必设置此值

@ApiParam   标注在参数上(如果参数是由实体注入的, 则在实体的字段上标注)
  name    参数名, 如果设置了将会无视参数名或字段名
  type    参数类型, 当需要自定义时(比如参数类型是枚举, 但是可以传 int 时)有用
  must    参数是否必须
  desc    参数说明, 请务必设置此值

@ApiParamIgnore 标注在参数上(如果参数是由实体注入的, 则在实体的字段上标注). 如果不希望参数出现在文档中, 使用此注解

@ApiReturn  标注在字段上. 用来说明返回结果
  type    返回类型, 当需要自定义时(比如字段类型是枚举, 但是返回却是 int 时)有用
  desc    返回说明, 请务必设置此值

@ApiReturnIgnore 标注在字段上. 如果不希望返回字段出现在结果文档中, 使用此注解
#+END_EXAMPLE

运行项目, 浏览 http://ip:port/api-info.html 查看文档(如果使用了下面的配置将会无法查看)
#+BEGIN_SRC yml
spring:
  mvc.throw-exception-if-no-handler-found: true
  resources.add-mappings: false
#+END_SRC

当前项目只是针对文档. 相比于 springfox(swagger) 做了很多的精简, 比如没有即时调试, 返回结果的呈现格式, 参数类型等

比如有如下相关的代码(去掉了 set get 方法)
#+BEGIN_SRC java
@ApiGroup({"product-商品模块"})
@RestController
public class ProductController {
    @ApiMethod(title = "接口测试")
    @GetMapping("/demo")
    public JsonResult<PageInfo<DemoVo>> demo(DemoDto demoDto, Page page) {
        return JsonResult.success("msg", null);
    }
}
class DemoDto {
    @ApiParam(desc = "用户 id")
    private Long userId;
    @ApiParam(type = "int", desc = "性别")
    private Gender gender;
}
class Page {
    @ApiParam(desc = "当前页数. 不传或传入 0, 或负数, 或非数字则默认是 1")
    private Integer page;
    @ApiParam(desc = "每页条数. 不传或传入 0, 或负数, 或非数字, 或大于 1000 则默认是 15")
    private Integer limit;
}
class JsonResult<T> {
    @ApiReturn(desc = "返回码. 前台根据此值控制页面扭转: 0.显示 msg, 1.业务处理, 10.导向登录页")
    private int code;
    @ApiReturn(desc = "返回说明. 如: 用户名密码错误, 收货地址添加成功 等")
    private String msg;
    @ApiReturn(desc = "返回的数据. 具体是返回实体 {\"id\":1} 还是列表 [{\"id\":1},{\"id\":2}] 依具体的业务而定")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private T data;

    // success fail...
}
class PageInfo<T> {
    @ApiReturn(desc = "总条数. 根据此值和 page limit 构建分页按钮")
    private int total;
    @ApiReturn(desc = "当前页的数据")
    private List<T> list;
}
class DemoVo {
    @ApiReturn(desc = "用户 id")
    private String userId;
}

enum Gender {
    Male(1, "男"), Female(2, "女");

    int code;
    String value;
    Gender(int code, String value) {
        this.code = code;
        this.value = value;
    }

    public String getValue() {
        return value;
    }
    @JsonValue
    public int getCode() {
        return code;
    }
    @JsonCreator
    public static Gender deserializer(Object obj) {
        return U.toEnum(Gender.class, obj);
    }
}
#+END_SRC

最终效果如下
[[https://raw.githubusercontent.com/liuanxin/image/master/api.png]]
