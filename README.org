
** 说明

长时间维护过项目的人应该都能体会, 如果接口文档是单独编写的话, 随着项目周期的推进, 接口文档和真实代码之间的差距会越来越远.

当前项目用来收集项目中的接口文档, 跟随项目. 代码运行起来文档也就有了, 修改代码的同时, 改标注在其上的说明即可.

** 使用

添加引用(需要 jackson 和 lombok 以及 spring mvc 相关的包)
#+BEGIN_SRC xml
<dependency>
    <groupId>com.github.liuanxin</groupId>
    <artifactId>api-document</artifactId>
    <version>0.0.1</version>
</dependency>
#+END_SRC

添加如下配置
#+BEGIN_SRC java
@Configuration
@EnableApiInfo
public class ApiInfoConfig {
    @Bean
    public DocumentCopyright urlCopyright() {
        // 线上环境文档对应的接口将不会输出
        return new DocumentCopyright()
                    .setTitle("文档总标题")
                    .setContact("文档项目组")
                    .setTeam("开发团队")
                    .setVersion("文档版本号")

                    // true 表示是线上环境, 默认是 false
                    .setOnline(true)
                    // 返回字段说明是否写在返回示例中, 默认是 true
                    .setCommentInReturnExample(false)
                    // 当某些接口不好标 @ApiIgnore 时(格式: url|method, url 可以使用 * 通配 method 可以忽略)
                    .setIgnoreUrlSet(Sets.newHashSet("/user*", "/product/info|post"));
    }
}
#+END_SRC

而后需要在对应的 controller 层标注相应的注解(只对 @RestController 或 @ResponseBody 相关的类及接口进行收集, 不支持 ResponseEntity 这一类没有无参构造的返回).

相关注解如下
#+BEGIN_EXAMPLE
@ApiGroup   标注在类或方法上. 表示当前接口隶属哪个模块. 如果类上和方法上都标了则以方法上的为准
  value   请务必设置此值, 示例(name-说明, 如: user-用户模块), 可以有多个, 也就是说一个接口可以在多个模块中出现

@ApiIgnore  标注在类或方法上. 当想要在某个类或接口上忽略收集时, 使用此注释
  value   值如果是 false 则表示不忽略. 类上和方法上都标了则以方法上的为准

@ApiMethod  标注在方法上
  title   接口标题, 请务必设置此值
  desc    接口详细说明
  develop 开发者信息, 请务必设置此值

@ApiParam   标注在参数上(如果参数是由实体注入的, 则在实体的字段上标注)
  name    参数名, 如果设置了将会无视参数名或字段名
  type    参数类型, 当需要自定义时(比如参数类型是枚举, 但是可以传 int 时)有用
  must    参数是否必须
  desc    参数说明, 请务必设置此值

@ApiParamIgnore 标注在参数上(如果参数是由实体注入的, 则在实体的字段上标注). 如果不希望参数出现在文档中, 使用此注解

@ApiReturn  标注在字段上. 用来说明返回结果
  type    返回类型, 当需要自定义时(比如字段类型是枚举, 但是返回却是 int 时)有用
  desc    返回说明, 请务必设置此值

@ApiReturnIgnore 标注在字段上. 如果不希望返回字段出现在结果文档中, 使用此注解
#+END_EXAMPLE

如果是非 spring boot 项目, 添加如下配置
#+BEGIN_SRC xml
<mvc:resources mapping="/static/**" location="classpath:/static/" />
#+END_SRC
运行项目, 浏览 http://ip:port/static/api-info.html 查看文档(spring boot 则不需要 /static 二级目录)

当前项目只是针对文档. 相比于 springfox(swagger) 做了很多的精简, 比如没有即时调试, 返回结果的呈现格式, 参数类型等

** 示例
比如有如下相关的代码(去掉了 set get 方法)
#+BEGIN_SRC java
@RestController
@RequestMapping("/user")
@ApiGroup({"user-用户模块"})
public class UserController {

    @ApiMethod(title = "测试接口", develop = "who")
    @GetMapping("/demo")
    public JsonResult<PageInfo<DemoVo>> demo(@ApiParam(desc = "用户名") String name,
                                             DemoDto demoDto, Page page) {
        return JsonResult.success("test");
    }
}

public class DemoDto {

    @ApiParam(must = true, desc = "用户 id")
    private Long userId;
    
    @ApiParam(type = "int", desc = "性别")
    private Gender gender;
    
    // set get ...
}

public class Page {

    @ApiParam(desc = "当前页数. 不传或传入 0, 或负数, 或非数字则默认是 1")
    private Integer page;
    
    @ApiParam(desc = "每页条数. 不传或传入 0, 或负数, 或非数字, 或大于 1000 则默认是 15")
    private Integer limit;
    
    // set get ...
}

public class JsonResult<T> {

    @ApiReturn(desc = "返回码. 根据此值控制页面扭转: 0.显示 msg, 1.业务处理, 10.导向登录页")
    private int code;
    
    @ApiReturn(desc = "返回说明. 如: 用户名密码错误, 收货地址添加成功 等")
    private String msg;
    
    @ApiReturn(desc = "返回的数据. 返回实体 {\"id\":1} 还是列表 [{\"id\":1},{\"id\":2}] 依具体的业务而定")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private T data;

    // set get ...
    // static success fail...
}

public class PageInfo<T> {

    @ApiReturn(desc = "总条数. 根据此值和 page limit 构建分页按钮")
    private int total;
    
    @ApiReturn(desc = "当前页的数据")
    private List<T> list;
    
    // set get ...
}

public class DemoVo {

    @ApiReturn(desc = "用户 id")
    private String userId;
    
    @ApiReturn(type = "int", desc = "性别")
    private Gender gender;
    
    // set get ...
}

public enum Gender {
    Male(0, "男"), Female(1, "女");
    
    int code;
    String value;
    Gender(int code, String value) {
        this.code = code;
        this.value = value;
    }

    // 收集文档时遇到枚举会自动获取 getCode() 和 getValue() 进行显示, 如果没有则会收集 name() 返回

    public String getValue() {
        return value;
    }
    @JsonValue // 序列化规则
    public int getCode() {
        return code;
    }
    @JsonCreator // 反序列化规则
    public static Gender deserializer(Object obj) {
        if (obj == null) {
            return null;
        }

        String source = obj.toString().trim();
        for (Gender em : values()) {
            // 如果传递过来的是枚举名, 且能匹配上则返回
            if (source.equalsIgnoreCase(em.name())) {
                return em;
            }
            // 如果传递过来的值跟枚举的 code(数字) 相同则返回
            if (source.equalsIgnoreCase(String.valueOf(em.getCode()))) {
                return em;
            }

            // 如果传递过来的值跟枚举的 value(中文) 相同则返回
            if (source.equalsIgnoreCase(em.getValue())) {
                return em;
            }

            // 如果传递过来的值跟枚举的 ordinal(数字. 表示枚举所在的索引) 相同则返回
            // if (source.equalsIgnoreCase(String.valueOf(em.ordinal()))) {
            //     return em;
            // }
        }
        return null;
    }
}
#+END_SRC

-----

最终文档收集如下
[[https://raw.githubusercontent.com/liuanxin/image/master/api.png]]

-----

如果将 commentInReturnExample 设置为 false 后最终将会显示成这样
[[https://raw.githubusercontent.com/liuanxin/image/master/api2.png]]

-----

gl hf...
